1.FREQUENCY OF EACH CHARACTER IN STRING

class p1
{
public static void frequency(String str)
  {
    int[] freq = new int[26];
    for (int i = 0; i < str.length(); i++)
    {
      freq[str.charAt(i) - 'a']++;
    }
    for (int i = 0; i < 26; i++)
    {
      if (freq[i] != 0)
      {
        System.out.print((char)(i + 'a'));
        System.out.print(freq[i] + " ");
      }
    }
  }
  }
  
2.MAX OCCURING CHARACTER

char Max(String s) {
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        int maxF = 1, currF = 1;
        char ans = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1]) {
                currF++;
            } 
            else {
                if (currF > maxF) {
                    maxF = currF;
                    ans = arr[i - 1];
                }
                currF = 1;
            }
        }
        if (currF> maxF) {
            maxF= currF;
            ans = arr[arr.length - 1];
        }
        return ans;
    }

3.REMOVE DUPLICATES FROM A STRING

String remove(String s){
HashSet<Character> set=new HashSet<>();
StringBuilder st=new StringBuilder();
for(char c:s.toCharArray()){
if(!set.contains(c)){
set.add(c);
st.append(c);
}
}
return st.toString();
}

4.Count the number of words in a given string
int words(String s){
int w=0;
for(char c:s.toCharArray()){
if(c==' ') w++;
}
return w+1;
}

5.FACTORIAL OF A NUMBER

int fact(int n){
int ans=1;
for(int i=2;i<=n;i++) ans*=i;
return ans;
}

6.POWER OF A NUMBER

class Solution {
    public int reverseExponentiation(int n) {
        int num = n;
        int d = 0, rev = 0;

        while (n > 0) {
            d = n % 10;
            rev = rev * 10 + d;
            n = n / 10;
        }

        return (int) Math.pow(num, rev);
    }
}

7.PRINT

class Solution {
    static void printTillN(int N) {
        int i = 1;
        while (i <= N) {
            System.out.print(i + " ");
            i++;
        }
    }
}

8.COUNT
// User function Template for Java

class Solution {
    static int evenlyDivides(int n) {
        // code here
        int c=0,d=0,num=n;
        while(n>0){
        d=n%10;
        if(d !=0){
        if(num%d ==0) c++;
        }
        n=n/10;
        }
        return c;
    }
}

9.SUM OF ARRAY

// User function Template for Java

class Solution {
    int arraySum(int arr[]) {
        // code here
        int s=0;
        for(int n:arr) s+=n;
        return s;
    }
}

10.FIND PIVOT INDEX
class Solution {
    public int pivotIndex(int[] nums) {
        int n=nums.length;
        int[] ls=new int[n];
        int[] rs=new int[n];
        int s=nums[0];
        ls[0]=nums[0];

        for(int i=1;i<n;i++){
            s+=nums[i];
          ls[i]=s;
        }
        rs[n-1]=nums[n-1];
        s=nums[n-1];
        for(int i=n-2;i>=0;i--){
            s+=nums[i];
            rs[i]=s;
        }
        int ans=-1;
        for(int i=0;i<n;i++){
           if(rs[i]==ls[i]){
            ans=i;
            break;
           }
        }
        return ans;
    }
}

11. FIBONACCI SERIES
class Solution {
   
    public int nthFibonacci(int n) {
        // code here
        if(n==0) return 0;
        if(n==1 || n==2) return 1;
        return nthFibonacci( n-1)+nthFibonacci( n-2);
        
        
    }
}

12.TOWER OF HANOI

class Solution {
    int c=0;
    public int towerOfHanoi(int n, int from, int to, int aux) {
        // code here
        if(n==0) return 0;
        towerOfHanoi(n-1,from,aux,to);
        c++;
        towerOfHanoi(n-1,aux,to,from);
        return c;
    }
}

13.SPIRAL MATRIX

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int col=matrix.length;
        int row=matrix[0].length;
        ArrayList<Integer> list=new ArrayList<>();
        int top=0,bottom=col-1,left=0,right=row-1;
        while(top<=bottom && left<=right){
            //for left to right
            for(int i=left;i<=right;i++) list.add(matrix[top][i]);
            top++;
          
          //for top to bottom(side col)
         
         for(int i=top;i<=bottom;i++) list.add(matrix[i][right]);
         right--;
          

         //for bottom row right to left
         if(top<=bottom){
         for(int i=right;i>=left;i--) list.add(matrix[bottom][i]);
         bottom--;
         }

         //for bottom to top
         if(left<=right){
         for(int i=bottom;i>=top;i--) list.add(matrix[i][left]);
         left++;
         }
        }
        return list;
    }
}

14.SEARCH IN 2D MATRIX

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length;
        int n=matrix[0].length;
        int top=0,bottom=m-1;
        while(top<=bottom){
            int mid=(top+bottom)/2;
            if(matrix[mid][0]==target || matrix[mid][n-1]== target) return true;
            else if(matrix[mid][0]< target && matrix[mid][n-1]> target){
                int left=0,right=n-1;
                while(left<=right){
                    int mv=(left+right)/2;
                    if(matrix[mid][mv]== target) return true;
                    else if(matrix[mid][mv]< target) left=mv+1;
                    else right=mv-1;
                }
                return false; 
            }
            else if(matrix[mid][0]>target) bottom=mid-1;
            else top=mid+1;
        }
        return false;
    }
}

15.SORT IN ARRAY

class Solution {
    public int[] sortArray(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void mergeSort(int[] array, int low, int high) {
        if (low >= high) {
            return;
        }
        int mid = low + (high - low) / 2;
        mergeSort(array, low, mid);
        mergeSort(array, mid + 1, high);
        merge(array, low, mid, high);
    }

    private void merge(int[] array, int low, int mid, int high) {
        int n1 = mid - low + 1;
        int n2 = high - mid;
        int[] leftPart = new int[n1];
        int[] rightPart = new int[n2];

        System.arraycopy(array, low, leftPart, 0, n1);
        System.arraycopy(array, mid + 1, rightPart, 0, n2);

        int p1 = 0, p2 = 0, writeInd = low;
        while (p1 < n1 && p2 < n2) {
            if (leftPart[p1] <= rightPart[p2]) {
                array[writeInd++] = leftPart[p1++];
            } else {
                array[writeInd++] = rightPart[p2++];
            }
        }

        while (p1 < n1) {
            array[writeInd++] = leftPart[p1++];
        }

        while (p2 < n2) {
            array[writeInd++] = rightPart[p2++];
        }
    }
}


16.MAX ONES
class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int[]  ans=new int[2];
        int c,r=0,maxc=Integer.MIN_VALUE;
        for(int i=0;i<mat.length;i++){
            c=0;
            for(int j=0;j<mat[0].length;j++){
                if(mat[i][j]==1) c++;
            }
              if(c>maxc){
                maxc=c;
                r=i;
              }
        }
        ans[0]=r;
        ans[1]=maxc;
        return ans;
    }
}
