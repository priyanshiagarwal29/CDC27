1.PREORDER TRAVERSAL

class Solution {
    public List<Integer> preorder(TreeNode root, ArrayList<Integer> ans){
        if(root == null) return ans;
        ans.add(root.val);
       preorder(root.left,ans);
       preorder(root.right,ans);
      return ans;
    }
    public List<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> ans=new ArrayList<>();
        return preorder(root,ans);
    }
}

2.INORDER TRAVERSAL

class Solution {
    public void traversal(TreeNode root,List<Integer> ans){
        if(root== null) return;
        if(root.left !=null)
        traversal(root.left,ans);
        ans.add(root.val);
        if(root.right !=null)
        traversal(root.right,ans);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
                List<Integer> ans= new ArrayList<>();
              traversal(root,ans);
              return ans;
    }
}

3.POSTORDER TRAVERSAL

class Solution {
    public List<Integer> post(TreeNode root,List<Integer> ans){
        if(root == null) return ans;
        post(root.left,ans);
        post(root.right,ans);
        ans.add(root.val);
        return ans;
    }
    public List<Integer> postorderTraversal(TreeNode root) {
        ArrayList<Integer> ans=new ArrayList<>();
        return post(root,ans);
    }
}

4.BINARY TREE ORDER TRAVERSAL

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
         Queue<TreeNode> q=new LinkedList<>();
        List<List<Integer>> ans=new ArrayList<>();
        List<Integer> e=new ArrayList<>();
        if(root == null) return ans;
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            e=new ArrayList<>();
            for(int i=0;i<size;i++){
            TreeNode curr=q.poll();
            e.add(curr.val);
            if(curr.left != null) q.add(curr.left);
            if(curr.right != null) q.add(curr.right);
            }
            ans.add(e);
        }
        return ans;
    }
}

5.Maximum Depth of Tree

class Solution {
    public int solve(TreeNode root){
        if(root==null) return 0;
        if(root.left == null && root.right ==null) return 1;
        return 1+Math.max(solve(root.left),solve(root.right));
    }
    public int maxDepth(TreeNode root) {
        return solve(root);
    }
}

6.SAME TREE

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);

    }
}

7.SYMMETRIC TREE

class Solution {
    public TreeNode invert(TreeNode root){
        if(root ==null) return null;
        if(root.left==null && root.right==null) return root;
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        invert(root.left);
        invert(root.right);
        return root;
    }
    public boolean isSameTree(TreeNode p,TreeNode q){
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);

    }
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        root.left=invert(root.left);
        return isSameTree(root.left,root.right);

        
    }
}

8.LOWER BOUND
class Sol{
   public static void Main(int target,int[] arr) {
    int s=0,e=arr.length-1;
int ind;
while(s<=e){
int mid=(s+e)/2;
if(arr[mid]>=target){
ind=mid;
e=mid-1;
}
else{
s=mid+1;
}
   }
return ind;
}
}

9.UPPER BOUND
class Sol{
   public static void Main(int target,int[] arr) {
    int s=0,e=arr.length-1;
int ind;
while(s<=e){
int mid=(s+e)/2;
if(arr[mid]<=target){
ind=mid;
s=mid+1;
}
else{
e=mid-1;
}
   }
return ind;
}
}


10.KOKO EATING BANANAS
class Solution {
    public long speed(int[] piles,int mid){
        long hr=0;
        for(int pile:piles){
            if(pile % mid==0){
                hr+=pile/mid;
            }
            else if(pile <mid){
                hr++;
            }
          else{
            hr+=(pile/mid)+1;
          }
        }
        return hr;
    }
    public int minEatingSpeed(int[] piles, int h) {
        int max=0;
      for(int pile:piles){
        max=Math.max(max,pile);
      }
      int s=1,e=max,mid;
      int ans=0;
      long hr;
      while(s<=e){
        mid=s+(e-s)/2;
       hr= speed(piles,mid);
       if(hr<=h){
        ans=mid;
        e=mid-1;
       }
       else{
        s=mid+1;
       }
      }
      return ans;

    }
}

11.BAD VERSION


/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left=1,right=n;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(isBadVersion(mid)) right=mid-1;
            else left=mid+1;
        }
        return left;
    }
}

12.SEARCH IN ROTATED SORTED ARRAY

class Solution {
    public int search(int[] nums, int target) {
        int l=0,r=nums.length-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            if(nums[mid]==target) return mid;
           else if(nums[mid]>=nums[l]){
            if(nums[l]<=target && target<=nums[mid]){
                r=mid-1;
            }
            else l=mid+1;
           }
           else{
            if(nums[mid]<=target && target<=nums[r]){
                l=mid+1;}
    else 
                r=mid-1;
            
           }
        }
       
       
        return -1;
    }
}

13.SEARCH IN ROTATED SORTED ARRAY 2

class Solution {
    public boolean search(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target) return true;
            if (nums[left] == nums[mid]) {
                left++;
                continue;
            }
            if (nums[right] == nums[mid]) {
                right--;
                continue;
            } 
            else if(nums[left]<=nums[mid]){
                if(nums[left]<=target && target<=nums[mid]) right=mid-1;
                else left=mid+1;
            }
            else{
                if(nums[mid]<=target && target<=nums[right]) left=mid+1;
                else right=mid-1;
            }
        }
        return false;
    }
}

14.AGGRESSIVE COWS

