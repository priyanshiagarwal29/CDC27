1.PREORDER TRAVERSAL

class Solution {
    public List<Integer> preorder(TreeNode root, ArrayList<Integer> ans){
        if(root == null) return ans;
        ans.add(root.val);
       preorder(root.left,ans);
       preorder(root.right,ans);
      return ans;
    }
    public List<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> ans=new ArrayList<>();
        return preorder(root,ans);
    }
}

2.INORDER TRAVERSAL

class Solution {
    public void traversal(TreeNode root,List<Integer> ans){
        if(root== null) return;
        if(root.left !=null)
        traversal(root.left,ans);
        ans.add(root.val);
        if(root.right !=null)
        traversal(root.right,ans);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
                List<Integer> ans= new ArrayList<>();
              traversal(root,ans);
              return ans;
    }
}

3.POSTORDER TRAVERSAL

class Solution {
    public List<Integer> post(TreeNode root,List<Integer> ans){
        if(root == null) return ans;
        post(root.left,ans);
        post(root.right,ans);
        ans.add(root.val);
        return ans;
    }
    public List<Integer> postorderTraversal(TreeNode root) {
        ArrayList<Integer> ans=new ArrayList<>();
        return post(root,ans);
    }
}

4.BINARY TREE ORDER TRAVERSAL

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
         Queue<TreeNode> q=new LinkedList<>();
        List<List<Integer>> ans=new ArrayList<>();
        List<Integer> e=new ArrayList<>();
        if(root == null) return ans;
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            e=new ArrayList<>();
            for(int i=0;i<size;i++){
            TreeNode curr=q.poll();
            e.add(curr.val);
            if(curr.left != null) q.add(curr.left);
            if(curr.right != null) q.add(curr.right);
            }
            ans.add(e);
        }
        return ans;
    }
}

5.Maximum Depth of Tree

class Solution {
    public int solve(TreeNode root){
        if(root==null) return 0;
        if(root.left == null && root.right ==null) return 1;
        return 1+Math.max(solve(root.left),solve(root.right));
    }
    public int maxDepth(TreeNode root) {
        return solve(root);
    }
}

6.SAME TREE

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);

    }
}

7.SYMMETRIC TREE

class Solution {
    public TreeNode invert(TreeNode root){
        if(root ==null) return null;
        if(root.left==null && root.right==null) return root;
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        invert(root.left);
        invert(root.right);
        return root;
    }
    public boolean isSameTree(TreeNode p,TreeNode q){
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);

    }
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        root.left=invert(root.left);
        return isSameTree(root.left,root.right);

        
    }
}
